	#define bool int

	#define BOBYQA_SUCCESS           0 // algorithm converged
	#define BOBYQA_BAD_NPT          -1 // NPT is not in the required interval
	#define BOBYQA_TOO_CLOSE        -2 // insufficient space between the bounds
	#define BOBYQA_ROUNDING_ERRORS  -3 // too much cancellation in a denominator
	#define BOBYQA_STEP_FAILED      -5 // a trust region step has failed to reduce Q

	int	bobyqa(long n, long npt, double (*objfun)(double*, void*),
			double* x, double* xl, double* xu, double rhobeg,
			double rhoend, double* w, void* data);

	typedef struct
	{
		char	Name[255];
		int	nJs;
		int	nSpinGroups;
		char	Symbols[21];
		char	SymbolsParsed[21];
		int	nSpins[21];
		double* ResFreq;	// -> Parameters[1]
		double* LW;		// -> Parameters[(nSpinGroups-1)+1+1]
		double	LB;
		int	JIdx[21];
		double* Js;		// -> Js[1]=Parameters[2]..., Js[(nSpinGroups-1)]=Parameters[(nSpinGroups-1)+1]
		int	nParams;
		double	Parameters[23];
		double	TotalWidth;
		bool	Sym;
		int	nLines;
		int*	LineJCombs;
		int*	LineMult;
		int	ZeroLineMult;
		int	nVarParams;
		int	VarParsIdx[23];
		int	nLBs;
		double	MaxLB;
		double* LBs;
		int	nPoints;
		double* PoitsFreq;
		double* TheorPoits;
		double* ExpPoits;
		double  ReScale;
		void	(*Calc)(void*);
	} Multiplet;

	void*	GetGlobalMultiplet(void);
	bool	InitMultiplet(void*);
	bool	ShowInteractiveForm(void*);
	double	Badness(double*, void*);
	void	quickSortIdx(double*, int*, int, int);

	char	textline[512] = { 0 };
	char	resultfile[256] = { 0 };
	int	i = 0, j = 0, k = 0;

	usleep(50000);
	//if (kbhit() != 0) { getch(); fflush(stdin); }
	while (kbhit()) getch();
	fflush(stdin);

	Multiplet* M = GetGlobalMultiplet();
	if(i_argc > 2) strcpy(M->Name, i_argv[2]);
	else M->Name[0] = '6';

	if(InitMultiplet(M) == 0) ABORT;

	// Get spectrum parameters
	double BF = 0, SF = 0, SWH = 0, O1 = 0;
	int SI = 0;
	FETCHPARS("BF1", &BF)
	FETCHPARS("O1", &O1)
	FETCHPARS("SW_h", &SWH)
	FETCHPARS("SF", &SF)
	FETCHPARS("SI", &SI)
	double FreqOffset = (BF - SF) * 1e6 + O1 + 0.5 * SWH;
	double OFFSET = FreqOffset / SF, FreqStep = SWH / SI;
	double PPMStep = FreqStep / SF;


	//////////////////////////////////////////////////////////////////
	// Get Multiplet Intervals from integrals data

	int nRanges = 0, StartPoint[20] = { 0 }, EndPoint[20] = { 0 };

	FILE* file = fopen(PROCPATH("integrals.txt"), "r");
	if(file == 0) { printf("Integrals file not found."); ABORT; }

	while(fgets(textline, 256, file))
		if (strstr(textline, "Integral") != NULL) break;
	while(fgets(textline, 256, file) && nRanges < 20)
	{
		sscanf(textline,"%*d%lf%lf", &d1, &d2);
		StartPoint[nRanges] = (int)((OFFSET - d1) / PPMStep);
		EndPoint[nRanges]   = (int)((OFFSET - d2) / PPMStep);
		nRanges++;
	}
	fclose(file);
	if(nRanges == 0) { printf("No integrals found, define at least one."); ABORT; }

	M->TotalWidth = (EndPoint[nRanges - 1] - StartPoint[0]) * FreqStep;
	//////////////////////////////////////////////////////////////////


	int* Spec = malloc(SI * sizeof(int)); memset(Spec, 0, SI * sizeof(int));
	int byteorder = 0;
	FETCHPARS("BYTORDP", &byteorder)

	file = fopen(PROCPATH("1r"), "r");
	if (fread(Spec, sizeof(int), SI, file) != SI) { printf("Experimental spectrum file failed to read!"); ABORT; }
	local_swap4(Spec, sizeof(int) * SI, byteorder);
	fclose(file);

	//Zeroing the spectrum outside multiplet regions
	for(i = 0, j = 0; i < SI; i++)
	{
		if(j < nRanges)	if(i == StartPoint[j]) { i = EndPoint[j] + 1 < SI ? EndPoint[j] + 1 : SI - 1; j++; }
		Spec[i] = 0;
	}

	int PivotPointIdx = 0; double Magnitude = 0; // Pivot point for magnitude rescale
	d1 = 0; d2 = 0;
	for(i = StartPoint[0]; i <= EndPoint[nRanges - 1]; i++)
	{
		if(Magnitude < Spec[i]) { Magnitude = Spec[i]; PivotPointIdx = i; }
		d1 += Spec[i] * (FreqOffset - i * FreqStep);
		d2 += Spec[i];
	}

	//Multiplet initial guess
	*M->ResFreq = d1 / d2;
	*M->LW = 1.0;
	if(ShowInteractiveForm(M) == 0) ABORT;

	// Prepearing output spectrum processing folder
	sprintf(resultfile,"%sMultiplet_%s_%.3lfp", PROCPATH(""), M->Name, *M->ResFreq / SF);
	sprintf(textline, "%s/pdata/999/procs", ACQUPATH(""));
	if(access(textline, R_OK | W_OK) == 0)
	{
		i1 = procno;
		RPROCNO(999)
		FETCHPARS("SI", &i2)
		FETCHPARS("SF", &d2)
		RPROCNO(i1)
		i1 = 0;
		if((SF != d2) || (SI != i2)) i1 = 1;
	}
	else i1 = 1;
	if(i1) WRP(999)

	double* Lorentz = NULL;
	i = (int)(ceil(sqrt(199) * M->MaxLB / (2 * FreqStep))) + 1;
	if (i > 4)
	{
		Lorentz = malloc(i * sizeof(double));
		memset(Lorentz, 0, i * sizeof(double));
	}

	M->nPoints = EndPoint[nRanges - 1] - StartPoint[0] + 2 * (int)ceil((1.2 * M->MaxLB) / FreqStep) + 2;
	double* Data = malloc(3 * M->nPoints * sizeof(double));
	memset(Data, 0, 3 * M->nPoints * sizeof(double));
	M->PoitsFreq  = Data;
	M->TheorPoits = Data + M->nPoints;
	M->ExpPoits   = Data + 2 * M->nPoints;

	// BOBYQA setup
	int n = M->nVarParams;
	double* WS = malloc((5 * n * (3 * n + 11) / 2 + 6) * sizeof(double));
	memset(WS, 0, (5 * n * (3 * n + 11) / 2 + 6) * sizeof(double));
	double Params[23]   = { 0 };
	double ParamsLB[23] = { 0 };
	double ParamsUB[23] = { 0 };

	for(i = 1; i <= n; i++)
	{
		Params[i]   =   M->Parameters[M->VarParsIdx[i]];
		ParamsLB[i] =  -M->TotalWidth;
		ParamsUB[i] =  +M->TotalWidth;
	}
	if(M->VarParsIdx[1] == 1)
	{
		ParamsLB[1] = FreqOffset - EndPoint[nRanges - 1] * FreqStep;
		ParamsUB[1] = FreqOffset - StartPoint[0] * FreqStep;
	}

	int StartPointIdx = 0, EndPointIdx = 0;

	FreeConsole();
	usleep(50000);
	AllocConsole();
	usleep(50000);
	SetConsoleCtrlHandler(NULL, FALSE);
	freopen("CONOUT$", "wt", stdout);
	freopen("CONIN$", "rt", stdin); 
	usleep(50000);

	for(i = 0; i < M->nLBs; i++)
	{

		///////////////////////////////////////////////////////////////////////////////////
		// Experimental spectrum broadening by convolution with Lorentz function
		i1 = (int)(ceil(sqrt(199) * M->LBs[i] / (2 * FreqStep)));
		if(i1 > 3)
		{
			M->LB = M->LBs[i];

			for(j = 0; j < i1; j++) Lorentz[j] = 1 / (1 + 4 * j * j * FreqStep * FreqStep / (M->LB * M->LB));

			StartPointIdx = StartPoint[0] - (int)ceil((1.2 * M->LB) / FreqStep);
			EndPointIdx = EndPoint[nRanges - 1] + (int)ceil((1.2 * M->LB) / FreqStep);
			if(StartPointIdx < 0) StartPointIdx = 0;
			if(EndPointIdx >= SI) EndPointIdx = SI - 1;

			M->nPoints = EndPointIdx - StartPointIdx + 1;

			for(j = StartPointIdx; j <= EndPointIdx; j++)
			{
				i2 = j - i1 + 1; if(i2 < 0) i2 = 0;
				i3 = j + i1 - 1; if(i3 >= SI) i3 = SI - 1;

				d1 = 0;
				for(k = i2; k <= i3; k++)
					d1 += Spec[k] * Lorentz[abs(j - k)];

				M->ExpPoits[j - StartPointIdx]  = d1;
				M->PoitsFreq[j - StartPointIdx] = FreqOffset - j * FreqStep;

			}

			d1 = Magnitude / M->ExpPoits[PivotPointIdx - StartPointIdx];
			for(j = 0; j < M->nPoints; j++) M->ExpPoits[j] *= d1;
		}
		else
		{
			M->LB = 0; // LB = 0, no additional broadening

			M->nPoints = 0;
			for(j = 0; j < nRanges; j++) M->nPoints += EndPoint[j] - StartPoint[j] + 1;

			for(j = 0, M->nPoints = 0; j < nRanges; j++)
				for(k = StartPoint[j]; k <= EndPoint[j]; k++)
				{
					M->ExpPoits[M->nPoints] = Spec[k];
					M->PoitsFreq[M->nPoints++] = FreqOffset - k * FreqStep;
				}
		}
		///////////////////////////////////////////////////////////////////////////////////

		printf("Broadening: %g\n", M->LB);

		if(i == 0 && n > 5) // Initial preopt of self guess
		{
			printf("Preliminary parameters preoptimizaion.\n");
			M->nVarParams = 5;
			i1 = M->VarParsIdx[5]; d1 = Params[5]; d2 = ParamsLB[5]; d3 = ParamsUB[5];
			if(M->VarParsIdx[n] == M->nSpinGroups + 1)
			{
				M->VarParsIdx[5] = M->VarParsIdx[n];
				Params[5] = Params[n];
				ParamsLB[5] = ParamsLB[n];
				ParamsUB[5] = ParamsUB[n];
			}
			bobyqa(5, 11, Badness, Params, ParamsLB, ParamsUB, 0.25 * M->TotalWidth, 1e-10, WS, M);
			M->nVarParams = n; M->VarParsIdx[5] = i1; ParamsLB[5] = d2; ParamsUB[5] = d3;
			if(M->VarParsIdx[n] == M->nSpinGroups + 1) { Params[n] = Params[5]; Params[5] = d1; }
			printf("\n");

		}

		bobyqa(n, 2 * n + 1, Badness, Params, ParamsLB, ParamsUB, 0.25 * M->TotalWidth, 1e-10, WS, M);
		printf("\n");

	}
	printf("\n");

	for(i = 1; i <= n; i++) if(M->VarParsIdx[i] > 1) Params[i] = fabs(Params[i]);
	for(i = 1; i <= n; i++) M->Parameters[M->VarParsIdx[i]] = Params[i];

	//Buildig J-couplings index according to its magnitude
	int JSortedIdx[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };
	quickSortIdx(M->Js, JSortedIdx, 1, M->nSpinGroups - 1);

	sprintf(textline,"%s.txt", resultfile);
	file = fopen(textline, "wt");

	printf("Hello!\n\n");
	printf("Res.Freq: %lf \/ %.3lf ppm\n", *M->ResFreq, *M->ResFreq / SF);
	fprintf(file, "Res.Freq: %lf \/ %.3lf ppm\n", *M->ResFreq, *M->ResFreq / SF);
	for(i = 1; i < M->nSpinGroups; i++)
	{

		if(M->nSpins[JSortedIdx[i] + 1] > 1) sprintf(textline, "%d*J%d", M->nSpins[JSortedIdx[i] + 1], i);
		else sprintf(textline, "J%d", i);
		printf("%-5s\t%lf\n", textline, M->Js[JSortedIdx[i]]);
		fprintf(file, "%-5s\t%lf\n", textline, M->Js[JSortedIdx[i]]);

	}
	printf("LW:  \t%lf\n", *M->LW);
	fprintf(file, "LW:  \t%lf\n", *M->LW);

	// R-Factor calculation
	double Badn = Badness(Params, M);
	for (i = 0, d1 = 0; i < M->nPoints; i++)
		d1 += M->ExpPoits[i] * M->ExpPoits[i];
	if(d1 > 0) d2 = 100 * sqrt(Badn / d1); else d2 = 1;
	printf("R-Factor: %.2lf%%\n\n\n", d2);
	fprintf(file, "R-Factor: %.2lf%%\n", d2);
	fclose(file);

	sprintf(textline,"notepad %s.txt", resultfile);
	STARTUPINFO si = { 0 }; si.cb = sizeof(si);
	PROCESS_INFORMATION pi = { 0 } ;
	CreateProcess(NULL, textline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

	StartPointIdx = StartPoint[0] - (int)ceil((1.2 * M->MaxLB) / FreqStep);
	EndPointIdx = EndPoint[nRanges - 1] + (int)ceil((1.2 * M->MaxLB) / FreqStep);
	if(StartPointIdx < 0) StartPointIdx = 0;
	if(EndPointIdx >= SI) EndPointIdx = SI - 1;
	for(i = StartPointIdx; i <= EndPointIdx; i++)
		M->PoitsFreq[i - StartPointIdx] = FreqOffset - i * FreqStep;
	M->nPoints = EndPointIdx - StartPointIdx + 1;

	M->Calc(M);

	d1 = M->ReScale;
	//d1 = Magnitude / M->TheorPoits[PivotPointIdx - StartPointIdx];
	for(i = 0; i < M->nPoints; i++) M->TheorPoits[i] *= d1;

	memset(Spec, 0, SI * sizeof(int));
	for(i = StartPointIdx; i <= EndPointIdx; i++)
		Spec[i] = M->TheorPoits[i - StartPointIdx];
	local_swap4(Spec, sizeof(int) * SI, byteorder);

	sprintf(textline, "%s/pdata/999/1r", ACQUPATH(""));
	file = fopen(textline, "w"); // = fopen(PROCPATH("1r"), "w");
	if (fwrite(Spec, sizeof(int), SI, file) != SI)
	{
		printf("Theoretical spectrum file failed to write!");
		ABORT;
	}
	fclose(file);
	sprintf(textline,"%s.1r", resultfile);
	file = fopen(textline, "w");
	if (fwrite(Spec, sizeof(int), SI, file) != SI)
	{
		printf("Theoretical spectrum file failed to write!");
		ABORT;
	}
	fclose(file);

	free(Data);
	free(Spec);
	free(WS);
	if(Lorentz != NULL) free(Lorentz);
	if(M->LineJCombs != NULL) free(M->LineJCombs);
	if(M->LineMult != NULL) free(M->LineMult);
	if(M->LBs != NULL) free(M->LBs);

	//freopen("CONIN$", "rt", stdin); 
	while (kbhit()) getch();
	i2 = 0; i3 = 11;
	for(i1 = 400; i1 > 0 && (!i2); i1--)
	{
		i2 = kbhit();
		if(i3 > round(i1 / 40.0))
		{
			i3 = i1 / 40;
			printf("\rWindow are closed in %d seconds. ", i3);
		}
		usleep(25000);
	}
	if(i2)
	{
		while (kbhit()) getch();
		printf("\r                                                         ");
		printf("\rPress any key to exit.", i1);
		getch();
	}

	FreeConsole();

	QUIT

	typedef struct
	{
		char	Name[255];
		int	nJs;
		int	nSpinGroups;
		char	Symbols[21];
		char	SymbolsParsed[21];
		int	nSpins[21];
		double* ResFreq;	// -> Parameters[1]
		double* LW;		// -> Parameters[(nSpinGroups-1)+1+1]
		double	LB;
		int	JIdx[21];
		double* Js;		// -> Js[1]=Parameters[2]..., Js[(nSpinGroups-1)]=Parameters[(nSpinGroups-1)+1]
		int	nParams;
		double	Parameters[23];
		double	TotalWidth;
		bool	Sym;
		int	nLines;
		int*	LineJCombs;
		int*	LineMult;
		int	ZeroLineMult;
		int	nVarParams;
		int	VarParsIdx[23];
		int	nLBs;
		double	MaxLB;
		double* LBs;
		int	nPoints;
		double* PoitsFreq;
		double* TheorPoits;
		double* ExpPoits;
		double  ReScale;
		void	(*Calc)(void*);
	} Multiplet;


Multiplet M = { 0 };

void*	GetGlobalMultiplet(void)
{
	return (void*)&M;
}

bool isunsignint(const char* text)
{

	bool res = (int)text[0] != 0;
	int i;
	for (i = 0; (res != 0) && ((int)text[i] != 0); i++)
		res = res && isdigit(text[i]);
	return(res);

}

bool isreal(char* text)
{
	bool res = text[0] != 0;
	int point = 0;
	int i = (text[0] == '-') || (text[0] == '+') ? 1 : 0;
	for (; (text[i] != 0) && res; i++)
	{
		if (text[i] == '.') point++;
		res = res && (point < 2) && (isdigit(text[i]) || text[i] == '.');
	}
	return(res);
}

void CalcMultiplet(void* D)
{
	Multiplet* M = (Multiplet*)D;

	memset(M->TheorPoits, 0, M->nPoints * sizeof(double));

	double LW = fabs(*M->LW) + M->LB;
	double sqHalfLW = LW * LW / 4;

	unsigned int nHalvedSpinStates = 1 << (M->nJs - 1);

	unsigned int i = 0, j = 0, tmp = 0;
	for (i = 0; i < nHalvedSpinStates; i++)
	{
		double SigmaJ = 0;
		for (j = 1, tmp = 1; j <= M->nJs; j++, tmp *= 2)
			SigmaJ += (i & tmp ? -1 : 1) * M->Js[M->JIdx[j]];

		for (j = 0; j < M->nPoints; j++)
		{

			double LineFreq = (*M->ResFreq) + 0.5 * SigmaJ;
			double tmp = M->PoitsFreq[j] - LineFreq; tmp *= tmp;
			M->TheorPoits[j] += 1 / (sqHalfLW + tmp);

			LineFreq = (*M->ResFreq) - 0.5 * SigmaJ;
			tmp = M->PoitsFreq[j] - LineFreq; tmp *= tmp;
			M->TheorPoits[j] += 1 / (sqHalfLW + tmp);

		}
	}

	return;
}

void CalcMultipletSym(void* D)
{
	Multiplet* M = (Multiplet*)D;

	memset(M->TheorPoits, 0, M->nPoints * sizeof(double));

	double LW = fabs(*M->LW) + M->LB;
	double sqHalfLW = LW * LW / 4;

	int nDiffJs = M->nSpinGroups - 1, i, j;

	if(M->ZeroLineMult)
		for (i = 0; i < M->nPoints; i++)
			{
				double tmp = M->PoitsFreq[i] - (*M->ResFreq); tmp *= tmp;
				M->TheorPoits[i] += M->ZeroLineMult / (sqHalfLW + tmp);
			}

	for (i = 0; i < M->nLines; i++)
	{
		double SigmaJ = 0;
		for (j = 0; j < nDiffJs; j++)
			SigmaJ +=  M->Parameters[j + 2] * M->LineJCombs[i * nDiffJs + j];

		for (j = 0; j < M->nPoints; j++)
		{
			double LineFreq = (*M->ResFreq) + 0.5 * SigmaJ;
			double tmp = M->PoitsFreq[j] - LineFreq; tmp *= tmp;
			M->TheorPoits[j] += M->LineMult[i] / (sqHalfLW + tmp);
                
			LineFreq = (*M->ResFreq) - 0.5 * SigmaJ;
			tmp = M->PoitsFreq[j] - LineFreq; tmp *= tmp;
			M->TheorPoits[j] += M->LineMult[i] / (sqHalfLW + tmp);
		}
	}

	return;
}

bool InitMultiplet(void* D)
{
	int i = 0, j = 0, k = 0, i1 = 0, i2 = 0, i3 = 0;
	double d1 = 0;

	Multiplet* M = (Multiplet*)D;

	if (isunsignint(M->Name))
	{
		M->nJs = atoi(M->Name);
		M->nSpinGroups = M->nJs + 1;
		if (M->nJs > 10) { printf("Maximum number of J-couplings(10) exceeded!\n"); return 0; }
		if (M->nJs == 0) { printf("At least one coupling constant should be present!\n"); return 0; }
		if (M->nSpinGroups > 1) d1 = ('Z' - 'A') / (double)(M->nSpinGroups - 1); else d1 = 0;

		for (i = 1; i <= M->nSpinGroups; i++)
		{
			M->Symbols[i] = 'A' + round(d1 * (i - 1));
			M->SymbolsParsed[i] = M->Symbols[i];
			M->nSpins[i] = 1;
		}
		if (M->Symbols[M->nSpinGroups] > 'Z') M->SymbolsParsed[M->nSpinGroups] = 'Z';

		for (i = 1; i < M->nSpinGroups; i++) M->JIdx[i] = i;
		for (i = 0; i < M->nSpinGroups; i++) M->Name[i] = M->SymbolsParsed[i + 1]; M->Name[i + 1] = 0;

		M->Sym = 0;
		M->Calc = CalcMultiplet;
	}
	else
	{
		if (M->Name[0] != 'a' && M->Name[0] != 'A')
		{
			printf("Spin system description must begin with symbol 'A'(or 'a')!\n");
			return 0;
		}

		for (i = 0; M->Name[i] != 0; i++)
			if (!isalnum(M->Name[i]))
			{
				printf("Spin system description can contain only alphabetic or numeric characters!\n");
				return 0;
			}

		M->nSpinGroups = 0;
		for (i = 0; M->Name[i] != 0; )
			if (isalpha(M->Name[i]))
			{
				j = 0;
				M->nSpinGroups++; M->nSpins[M->nSpinGroups] = 0;
				if (M->nSpinGroups > 10) { printf("Maximum number of spin types(10) exceeded!\n"); return 0; }
				// M->Symbols[M->nSpinGroups] = toupper(M->Name[i]);
				M->Name[i] = toupper(M->Name[i]); M->Symbols[M->nSpinGroups] = M->Name[i];
				i++;
				for (; M->Name[i] != 0; i++)
				{
					if (isdigit(M->Name[i])) { M->nSpins[M->nSpinGroups] *= 10; M->nSpins[M->nSpinGroups] += M->Name[i] - '0'; j = 1; }
					else break;
				}
				if (M->nSpins[M->nSpinGroups] == 0 && j == 0) M->nSpins[M->nSpinGroups] = 1;
				if (M->nSpins[M->nSpinGroups] == 0) { printf("Number of spins in group must be at least one!\n"); return 0; }
				if (M->nSpinGroups > 1) M->nJs += M->nSpins[M->nSpinGroups];
			}

		if (M->nSpinGroups > 10) { printf("Maximum number of magnetically equivalent spin groups(10) exceeded!\n"); return 0; }
		if (M->nJs > 20) { printf("Maximum number of J-couplings(20) exceeded!\n"); return 0; }
		if (M->nJs == 0) { printf("At least one coupling constant should be present!\n"); return 0; }

		if (M->nSpinGroups > 1) j = ('Z' - 'A') / (M->nSpinGroups - 1); else j = 0;
		for (i = 1; i <= M->nSpinGroups; i++)
			M->SymbolsParsed[i] = 'A' + j * (i - 1);

		for (j = 2, i = 0; j <= M->nSpinGroups; j++)
			for (k = 1; k <= M->nSpins[j]; k++) M->JIdx[++i] = j - 1;

		if (M->nJs > M->nSpinGroups - 1) // Spin system symmetry block.
		{
			M->Sym = 1;
			M->Calc = CalcMultipletSym;

			int CurrJFreq[21] = { 0 };
			int nDiffJs = M->nSpinGroups - 1;
			unsigned int nHalvedSpinStates = 1 << (M->nJs - 1);

			for (i = 2, j = 1; i <= M->nSpinGroups; i++)
				j *= M->nSpins[i] + 1;
			M->nLines = j / 2;

			M->LineJCombs = (int*)malloc(M->nLines * nDiffJs * sizeof(int));
			memset(M->LineJCombs, 0, M->nLines * nDiffJs * sizeof(int));
			M->LineMult = (int*)malloc(M->nLines * sizeof(int));
			memset(M->LineMult, 0, M->nLines * sizeof(int));

			for (i = 1; i <= M->nJs; i++) M->LineJCombs[M->JIdx[i] - 1]++;

			for (i = 0, i1 = 0; i < (int)nHalvedSpinStates; i++)
			{
				memset(CurrJFreq, 0, nDiffJs * sizeof(int));
				for (j = 1, k = 1; j <= M->nJs; j++, k *= 2)
					CurrJFreq[M->JIdx[j] - 1] += i & k ? -1 : 1;

				for (j = 0, i2 = 1; (j < nDiffJs) && i2; j++) i2 = CurrJFreq[j] == 0;
				if (i2) { M->ZeroLineMult += 2; continue; }

				for (j = 0, i2 = 0; (j <= i1) && (!i2); j++)
				{
					for (k = 0, i2 = 1; (k < nDiffJs) && i2; k++) i2 = M->LineJCombs[j * nDiffJs + k] == CurrJFreq[k];
					for (k = 0, i3 = 1; (k < nDiffJs) && i3; k++) i3 = M->LineJCombs[j * nDiffJs + k] == -CurrJFreq[k];
					i2 = i2 || i3;
				}
				if (i2) M->LineMult[j - 1]++;
				else
				{
					i1++;
					for (j = 0; j < nDiffJs; j++) M->LineJCombs[i1 * nDiffJs + j] = CurrJFreq[j];
					M->LineMult[i1]++;
				}

			}
			M->nLines = i1 + 1;
		}
		else
		{
			M->Sym = 0;
			M->Calc = CalcMultiplet;
		}
	}
	M->nParams = M->nSpinGroups + 1; // nDiffJs+2(ResFreq&LW)
	M->ResFreq = M->Parameters + 1;
	M->Js = M->Parameters + 1;
	M->LW = M->Parameters + M->nSpinGroups + 1;
	return 1;
}

void LBsParse(void* D, char* textline)
{

	Multiplet* M = (Multiplet*)D;

	int nUnsignedReals = 0;

	bool OnWord = 0;
	bool point = 0;
	bool isunsignedreal = 0;
	int i = 0;
	int last_word_offset = 0;

	for (i = 0; ; i++)
	{
		if (textline[i] == 0 ? 0 : !isspace(textline[i]))
		{
			if (!OnWord)
			{
				OnWord = 1;
				last_word_offset = i;
				i--;
				isunsignedreal = 1;
				point = 0;
				continue;
			}
			else
				if (isunsignedreal && !isdigit(textline[i]))
				{
					if (textline[i] != '.') isunsignedreal = 0;
					else
					{
						if (point) isunsignedreal = 0;
						point = 1;
					}
				}
		}
		if (textline[i] == 0 ? 1 : isspace(textline[i]))
		{
			if (OnWord)
			{
				OnWord = 0;
				if (isunsignedreal) nUnsignedReals++;
			}
			if (textline[i] == 0) break;
		}
	}

	if (nUnsignedReals > 0)
	{
		M->nLBs = nUnsignedReals;
		M->LBs = (double*)malloc(nUnsignedReals * sizeof(double));
		memset(M->LBs, 0, nUnsignedReals * sizeof(double));

		OnWord = 0; nUnsignedReals = 0;
		for (i = 0; ; i++)
		{
			if (textline[i] == 0 ? 0 : !isspace(textline[i]))
			{
				if (!OnWord)
				{
					OnWord = 1;
					last_word_offset = i;
					i--;
					isunsignedreal = 1;
					point = 0;
					continue;
				}
				else
					if (isunsignedreal && !isdigit(textline[i]))
					{
						if (textline[i] != '.') isunsignedreal = 0;
						else
						{
							if (point) isunsignedreal = 0;
							point = 1;
						}
					}
			}
			if (textline[i] == 0 ? 1 : isspace(textline[i]))
			{
				if (OnWord)
				{
					OnWord = 0;
					if (isunsignedreal)
					{
						sscanf(textline + last_word_offset, "%lf", M->LBs + nUnsignedReals);
						if (M->LBs[nUnsignedReals] > M->MaxLB) M->MaxLB = M->LBs[nUnsignedReals];
						nUnsignedReals++;
					}
				}
				if (textline[i] == 0) break;
			}
		}
	}
	else
	{
		M->nLBs = 1;
		M->LBs = (double*)malloc(sizeof(double));
		*M->LBs = 0;
		M->MaxLB = 0;
	}
	return;
}

#include <windows.h>

LRESULT WINAPI WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
	switch (Msg)
	{
		case WM_DESTROY:
				PostQuitMessage(0);
				break;
		default:
				return DefWindowProcA(hWnd, Msg, wParam, lParam);
	}
}

bool ShowInteractiveForm(void* D)
{

	Multiplet* M = (Multiplet*)D;
	int i = 0;
	WNDCLASSA wcl = { 0 };

	wcl.lpszClassName = "Window";
	wcl.lpfnWndProc = WinProc;
	RegisterClassA(&wcl);
	HWND hwnd = CreateWindowA("Window", M->Name, WS_OVERLAPPEDWINDOW & (~WS_THICKFRAME), 100, 200, 640, 190 + 43 * (M->nSpinGroups + 1), NULL, NULL, NULL, NULL);
	HDC dc = GetDC(hwnd);
	//ShowWindow(hwnd, SW_SHOWNORMAL);
	ShowWindow(hwnd, SW_SHOW);

	HFONT hFont = CreateFont(24, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, TEXT("Arial"));
	SelectObject(dc, hFont);
	SendMessage(hwnd, WM_SETFONT, (LPARAM)hFont, TRUE);

	HWND ParamsHwnd[23] = { 0 };
	HWND FixedHwnd[23] = { 0 };

	char textline[256];

	TextOutA(dc, 10, 10, M->Name, strlen(M->Name));
	TextOutA(dc, 110, 55, "Res.Freq.", 10);
	sprintf(textline, "%.4lf", *M->ResFreq);
	ParamsHwnd[1] = CreateWindowA("edit", textline, WS_VISIBLE | WS_CHILD | WS_BORDER | ES_RIGHT | WS_TABSTOP, 230, 53, 120, 30, hwnd, NULL, NULL, NULL);

	SendMessage(ParamsHwnd[1], WM_SETFONT, (LPARAM)hFont, TRUE);
	TextOutA(dc, 350, 25, "Fixed?", 6);
	FixedHwnd[1] = CreateWindowA("button", NULL, WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX | WS_TABSTOP, 370, 60, 12, 12, hwnd, NULL, NULL, NULL);

	for (i = 2; i <= M->nSpinGroups; i++)
	{
		if (M->nSpins[i] > 1) sprintf(textline, "%d*J%d", M->nSpins[i], i - 1);
		else sprintf(textline, "J%d", i - 1);
		TextOutA(dc, 110, 93 + 43 * (i - 2), textline, strlen(textline));
		sprintf(textline, "%.4lf", M->Js[i - 1]);
		ParamsHwnd[i] = CreateWindowA("edit", textline, WS_VISIBLE | WS_CHILD | WS_BORDER | ES_RIGHT | WS_TABSTOP, 230, 91 + 43 * (i - 2), 120, 30, hwnd, NULL, NULL, NULL);
		SendMessage(ParamsHwnd[i], WM_SETFONT, (LPARAM)hFont, TRUE);
		FixedHwnd[i] = CreateWindowA("button", NULL, WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX | WS_TABSTOP, 370, 100 + 43 * (i - 2), 12, 12, hwnd, NULL, NULL, NULL);
	}

	TextOutA(dc, 110, 93 + 43 * (M->nSpinGroups - 1), "LW", 2);
	sprintf(textline, "%.4lf", *M->LW);
	ParamsHwnd[M->nSpinGroups + 1] = CreateWindowA("edit", textline, WS_VISIBLE | WS_CHILD | WS_BORDER | ES_RIGHT | WS_TABSTOP, 230, 91 + 43 * (M->nSpinGroups - 1), 120, 30, hwnd, NULL, NULL, NULL);
	SendMessage(ParamsHwnd[M->nSpinGroups + 1], WM_SETFONT, (LPARAM)hFont, TRUE);
	FixedHwnd[M->nSpinGroups + 1] = CreateWindowA("button", NULL, WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX | WS_TABSTOP, 370, 100 + 43 * (M->nSpinGroups - 1), 12, 12, hwnd, NULL, NULL, NULL);

	sprintf(textline, "6.0 5.0 4.0 3.0 2.0 1.0 0.8 0.6 0.4 0.2 0.1 0.05 0.0");
	TextOutA(dc, 10, 93 + 43 * M->nSpinGroups, "LBs", 3);
	ParamsHwnd[M->nSpinGroups + 2] = CreateWindowA("edit", textline, WS_VISIBLE | WS_CHILD | WS_BORDER | ES_RIGHT | WS_TABSTOP, 60, 91 + 43 * M->nSpinGroups, 555, 30, hwnd, NULL, NULL, NULL);
	SendMessage(ParamsHwnd[M->nSpinGroups + 2], WM_SETFONT, (LPARAM)hFont, TRUE);

	ParamsHwnd[M->nSpinGroups + 3] = CreateWindowA("button", "RUN!", WS_VISIBLE | WS_CHILD | WS_TABSTOP, 190, 100 + 43 * (M->nSpinGroups + 1), 80, 40, hwnd, NULL, NULL, NULL);
	SendMessage(ParamsHwnd[M->nSpinGroups + 3], WM_SETFONT, (LPARAM)hFont, TRUE);

	ParamsHwnd[M->nSpinGroups + 4] = CreateWindowA("button", "Cancel", WS_VISIBLE | WS_CHILD | WS_TABSTOP, 290, 100 + 43 * (M->nSpinGroups + 1), 80, 40, hwnd, NULL, NULL, NULL);
	SendMessage(ParamsHwnd[M->nSpinGroups + 4], WM_SETFONT, (LPARAM)hFont, TRUE);

	MSG msg = { 0 };

	memset(textline, 0, 256);

	for(;;)
	{

		i = GetMessage(&msg, NULL, 0, 0);
		if (i == 0) break;
		if (msg.wParam == 27 || (msg.hwnd == ParamsHwnd[M->nSpinGroups + 4] && (msg.wParam == 1 || msg.wParam == 13))) { i = 0; break; }

		if ((msg.hwnd == ParamsHwnd[M->nSpinGroups + 3] && msg.wParam == 1) || msg.wParam == 13)
		{
			M->nVarParams = 0;
			for (i = 1; i <= M->nParams; i++)
			{
				if (SendMessage(FixedHwnd[i], BM_GETCHECK, 0, 0) == 0) M->VarParsIdx[++M->nVarParams] = i;
				GetWindowTextA(ParamsHwnd[i], (LPSTR)textline, 255);
				if (isreal(textline)) M->Parameters[i] = atof(textline); else M->Parameters[i] = 0;
			}
			GetWindowTextA(ParamsHwnd[M->nSpinGroups + 2], (LPSTR)textline, 255);
			LBsParse(M, textline);
			i = 1; break;
		}

		if(!IsDialogMessage(hwnd, &msg))
		{
			TranslateMessage(&msg); // Needed for edit vidget
			DispatchMessage(&msg);
		}
	}
	if(*M->LW == 0) *M->LW = 1;

	DestroyWindow(hwnd);
	UnregisterClassA("Window", 0);
	return i;
}


double Badness(double *Parameters, void* D)
{

	Multiplet* M = (Multiplet*)D;

	int i = 0; double tmp;

	for(i = 1; i <= M->nVarParams; i++) M->Parameters[M->VarParsIdx[i]] = Parameters[i];

	M->Calc(M);

	double TheorDotTheor = 0;
	double ExpDotTheor = 0;
	for(i = 0; i < M->nPoints; i++)
	{
		TheorDotTheor += M->TheorPoits[i] * M->TheorPoits[i];
                       ExpDotTheor += M->ExpPoits[i] * M->TheorPoits[i];
	}
	tmp = ExpDotTheor / TheorDotTheor;
	for(i = 0; i < M->nPoints; i++)
		M->TheorPoits[i] *= tmp;
	M->ReScale = tmp;

	tmp = 0;
	for(i = 0; i < M->nPoints; i++)
		tmp += (M->TheorPoits[i] - M->ExpPoits[i]) * (M->TheorPoits[i] - M->ExpPoits[i]);

	return tmp;

}

void quickSortIdx(double* array, int* index, int low, int high)
{
	int i = low;
	int j = high;
	double pivot = array[index[(i + j) / 2]];
	int temp;

	while (i <= j)
	{
		while (array[index[i]] > pivot)
			i++;
		while (array[index[j]] < pivot)
			j--;
		if (i <= j)
		{
			temp = index[i];
			index[i] = index[j];
			index[j] = temp;
			i++;
			j--;
		}
	}
	if (j > low)
		quickSortIdx(array, index, low, j);
	if (i < high)
		quickSortIdx(array, index, i, high);
}


/*
* BOBYQA
* The MIT License (MIT) Copyright (c) 2015
*
* Copyright (c) 2009, Mike Powell (FORTRAN version).
* Copyright (c) 2015, Eric Thiebaut (C version).
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Implementation of Mike Powell's BOBYQA algorithm for minimizing a function
* of many variables.  The method is "derivatives free" (only the function
* values are needed) and accounts for bound constraints on the variables.  The
* algorithm is described in:
*
*   M.J.D. Powell, "The BOBYQA Algorithm for Bound Constrained Optimization
*   Without Derivatives."  Technical report, Department of Applied Mathematics
*   and Theoretical Physics, University of Cambridge (2009).
*
* The present code is based on the original FORTRAN version written by Mike
* Powell who kindly provides his code on demand (at mjdp@cam.ac.uk) and has
* been converted to C by E. Thiebaut.
*
*/

#define LOOP(var,num)    for (var = 1; var <= num; ++var)
#define MAX(a,b)         ((a) >= (b) ? (a) : (b))
#define MIN(a,b)         ((a) <= (b) ? (a) : (b))
#define HOW_MANY(a,b)    ((((b) - 1) + (a))/(b))
#define ROUND_UP(a,b)    (HOW_MANY(a,b)*(b))

#define XPT(a1,a2)       xpt[(a2)*npt + a1]
#define BMAT(a1,a2)      bmat[(a2)*ndim + a1]
#define ZMAT(a1,a2)      zmat[(a2)*npt + a1]
#define PTSAUX(a1,a2)    ptsaux[(a2)*2 + a1]

void prelim(long n, long npt,
	double (*objfun)(double*, void*),
	double* x, double* xl, double* xu,
	double rhobeg, double* xbase, double* xpt,
	double* fval, double* gopt, double* hq, double* pq,
	double* bmat, double* zmat, long ndim,
	double* sl, double* su, long* nf, long* kopt, void* data)
{
	double half = 0.5;
	double one = 1.0;
	double two = 2.0;
	double zero = 0.0;
	double diff, f, fbeg, recip, rhosq, stepa, stepb, temp;
	long i, i1, ih, ipt, itemp, j, jpt, k, nfm, nfx, np;

	x -= 1;
	xl -= 1;
	xu -= 1;
	xbase -= 1;
	xpt -= 1 + npt;
	fval -= 1;
	gopt -= 1;
	hq -= 1;
	pq -= 1;
	bmat -= 1 + ndim;
	zmat -= 1 + npt;
	sl -= 1;
	su -= 1;
	stepa = zero;
	stepb = zero;
	fbeg = zero;
	ipt = 0;
	jpt = 0;
	rhosq = rhobeg * rhobeg;
	recip = one / rhosq;
	np = n + 1;

	LOOP(j, n) {
		xbase[j] = x[j];
		LOOP(k, npt) {
			XPT(k, j) = zero;
		}
		LOOP(i, ndim) {
			BMAT(i, j) = zero;
		}
	}
	i1 = n * np / 2;
	LOOP(ih, i1) {
		hq[ih] = zero;
	}
	LOOP(k, npt) {
		pq[k] = zero;
		i1 = npt - np;
		LOOP(j, i1) {
			ZMAT(k, j) = zero;
		}
	}

	*nf = 0;
	do {
		nfm = *nf;
		nfx = *nf - n;
		++(*nf);
		if (nfm <= 2 * n) {
			if (nfm >= 1 && nfm <= n) {
				stepa = rhobeg;
				if (su[nfm] == zero) {
					stepa = -stepa;
				}
				XPT(*nf, nfm) = stepa;
			}
			else if (nfm > n) {
				stepa = XPT(*nf - n, nfx);
				stepb = -rhobeg;
				if (sl[nfx] == zero) {
					stepb = two * rhobeg;
					stepb = MIN(stepb, su[nfx]);
				}
				if (su[nfx] == zero) {
					stepb = -two * rhobeg;
					stepb = MAX(stepb, sl[nfx]);
				}
				XPT(*nf, nfx) = stepb;
			}
		}
		else {
			itemp = (nfm - np) / n;
			jpt = nfm - itemp * n - n;
			ipt = jpt + itemp;
			if (ipt > n) {
				itemp = jpt;
				jpt = ipt - n;
				ipt = itemp;
			}
			XPT(*nf, ipt) = XPT(ipt + 1, ipt);
			XPT(*nf, jpt) = XPT(jpt + 1, jpt);
		}

		LOOP(j, n) {
			temp = xbase[j] + XPT(*nf, j);
			temp = MAX(temp, xl[j]);
			x[j] = MIN(temp, xu[j]);
			if (XPT(*nf, j) == sl[j]) {
				x[j] = xl[j];
			}
			if (XPT(*nf, j) == su[j]) {
				x[j] = xu[j];
			}
		}
		f = objfun(x, data); // objfun(n, &x[1], data);
		fval[*nf] = f;
		if (*nf == 1) {
			fbeg = f;
			*kopt = 1;
		}
		else if (f < fval[*kopt]) {
			*kopt = *nf;
		}

		if (*nf <= 2 * n + 1) {
			if (*nf >= 2 && *nf <= n + 1) {
				gopt[nfm] = (f - fbeg) / stepa;
				if (npt < *nf + n) {
					BMAT(1, nfm) = -one / stepa;
					BMAT(*nf, nfm) = one / stepa;
					BMAT(npt + nfm, nfm) = -half * rhosq;
				}
			}
			else if (*nf >= n + 2) {
				ih = nfx * (nfx + 1) / 2;
				temp = (f - fbeg) / stepb;
				diff = stepb - stepa;
				hq[ih] = two * (temp - gopt[nfx]) / diff;
				gopt[nfx] = (gopt[nfx] * stepb - temp * stepa) / diff;
				if (stepa * stepb < zero) {
					if (f < fval[*nf - n]) {
						fval[*nf] = fval[*nf - n];
						fval[*nf - n] = f;
						if (*kopt == *nf) {
							*kopt = *nf - n;
						}
						XPT(*nf - n, nfx) = stepb;
						XPT(*nf, nfx) = stepa;
					}
				}
				BMAT(1, nfx) = -(stepa + stepb) / (stepa * stepb);
				BMAT(*nf, nfx) = -half / XPT(*nf - n, nfx);
				BMAT(*nf - n, nfx) = -BMAT(1, nfx) - BMAT(*nf, nfx);
				ZMAT(1, nfx) = sqrt(two) / (stepa * stepb);
				ZMAT(*nf, nfx) = sqrt(half) / rhosq;
				ZMAT(*nf - n, nfx) = -ZMAT(1, nfx) - ZMAT(*nf, nfx);
			}
		}
		else {
			ih = ipt * (ipt - 1) / 2 + jpt;
			ZMAT(1, nfx) = recip;
			ZMAT(*nf, nfx) = recip;
			ZMAT(ipt + 1, nfx) = -recip;
			ZMAT(jpt + 1, nfx) = -recip;
			temp = XPT(*nf, ipt) * XPT(*nf, jpt);
			hq[ih] = (fbeg - fval[ipt + 1] - fval[jpt + 1] + f) / temp;
		}
	} while (*nf < npt);
}

void altmov(long n, long npt, double xpt[],
	double* xopt, double* bmat, double* zmat, long ndim,
	double* sl, double* su, long kopt, long knew,
	double adelt, double* xnew, double* xalt, double* alpha,
	double* cauchy, double* glag, double* hcol, double* w)
{

	double half = 0.5;
	double one = 1.0;
	double zero = 0.0;
	double one_plus_sqrt2 = one + M_SQRT2;
	double bigstp, csave, curv, dderiv, diff, distsq, ggfree, gw, ha,
		predsq, presav, scale, slbd, step, stpsav, subd, sumin,
		temp, tempa, tempb, tempd, vlag, wfixsq, wsqsav;
	long i, i1, ibdsav, iflag, ilbd, isbd, iubd, j, k, ksav;

	xpt -= 1 + npt;
	xopt -= 1;
	bmat -= 1 + ndim;
	zmat -= 1 + npt;
	sl -= 1;
	su -= 1;
	xnew -= 1;
	xalt -= 1;
	glag -= 1;
	hcol -= 1;
	w -= 1;
	csave = zero;
	stpsav = zero;
	step = zero;
	ksav = 0;
	ibdsav = 0;
	wsqsav = 0;

	LOOP(k, npt) {
		hcol[k] = zero;
	}
	i1 = npt - n - 1;
	LOOP(j, i1) {
		temp = ZMAT(knew, j);
		LOOP(k, npt) {
			hcol[k] += temp * ZMAT(k, j);
		}
	}
	*alpha = hcol[knew];
	ha = half * (*alpha);

	LOOP(i, n) {
		glag[i] = BMAT(knew, i);
	}
	LOOP(k, npt) {
		temp = zero;
		LOOP(j, n) {
			temp += XPT(k, j) * xopt[j];
		}
		temp = hcol[k] * temp;
		LOOP(i, n) {
			glag[i] += temp * XPT(k, i);
		}
	}

	presav = zero;
	LOOP(k, npt) {
		if (k == kopt) {
			continue;
		}
		dderiv = zero;
		distsq = zero;
		LOOP(i, n) {
			temp = XPT(k, i) - xopt[i];
			dderiv += glag[i] * temp;
			distsq += temp * temp;
		}
		subd = adelt / sqrt(distsq);
		slbd = -subd;
		ilbd = 0;
		iubd = 0;
		sumin = MIN(one, subd);

		LOOP(i, n) {
			temp = XPT(k, i) - xopt[i];
			if (temp > zero) {
				if (slbd * temp < sl[i] - xopt[i]) {
					slbd = (sl[i] - xopt[i]) / temp;
					ilbd = -i;
				}
				if (subd * temp > su[i] - xopt[i]) {
					subd = (su[i] - xopt[i]) / temp;
					subd = MAX(subd, sumin);
					iubd = i;
				}
			}
			else if (temp < zero) {
				if (slbd * temp > su[i] - xopt[i]) {
					slbd = (su[i] - xopt[i]) / temp;
					ilbd = i;
				}
				if (subd * temp < sl[i] - xopt[i]) {
					subd = (sl[i] - xopt[i]) / temp;
					subd = MAX(subd, sumin);
					iubd = -i;
				}
			}
		}

		if (k == knew) {
			diff = dderiv - one;
			step = slbd;
			vlag = slbd * (dderiv - slbd * diff);
			isbd = ilbd;
			temp = subd * (dderiv - subd * diff);
			if (abs(temp) > abs(vlag)) {
				step = subd;
				vlag = temp;
				isbd = iubd;
			}
			tempd = half * dderiv;
			tempa = tempd - diff * slbd;
			tempb = tempd - diff * subd;
			if (tempa * tempb < zero) {
				temp = tempd * tempd / diff;
				if (abs(temp) > abs(vlag)) {
					step = tempd / diff;
					vlag = temp;
					isbd = 0;
				}
			}
		}
		else {
			step = slbd;
			vlag = slbd * (one - slbd);
			isbd = ilbd;
			temp = subd * (one - subd);
			if (abs(temp) > abs(vlag)) {
				step = subd;
				vlag = temp;
				isbd = iubd;
			}
			if (subd > half) {
				if (abs(vlag) < 0.25) {
					step = half;
					vlag = 0.25;
					isbd = 0;
				}
			}
			vlag *= dderiv;
		}

		temp = step * (one - step) * distsq;
		predsq = vlag * vlag * (vlag * vlag + ha * temp * temp);
		if (predsq > presav) {
			presav = predsq;
			ksav = k;
			stpsav = step;
			ibdsav = isbd;
		}
	}

	LOOP(i, n) {
		temp = xopt[i] + stpsav * (XPT(ksav, i) - xopt[i]);
		temp = MIN(temp, su[i]);
		xnew[i] = MAX(temp, sl[i]);
	}
	if (ibdsav < 0) {
		xnew[-ibdsav] = sl[-ibdsav];
	}
	if (ibdsav > 0) {
		xnew[ibdsav] = su[ibdsav];
	}

	bigstp = adelt + adelt;
	iflag = 0;
	for (;;) {
		wfixsq = zero;
		ggfree = zero;
		LOOP(i, n) {
			w[i] = zero;
			tempa = xopt[i] - sl[i];
			tempa = MIN(tempa, glag[i]);
			tempb = xopt[i] - su[i];
			tempb = MAX(tempb, glag[i]);
			if (tempa > zero || tempb < zero) {
				w[i] = bigstp;
				ggfree += glag[i] * glag[i];
			}
		}
		if (ggfree == zero) {
			*cauchy = zero;
			return;
		}

		do {
			temp = adelt * adelt - wfixsq;
			if (temp <= zero) break;
			wsqsav = wfixsq;
			step = sqrt(temp / ggfree);
			ggfree = zero;
			LOOP(i, n) {
				if (w[i] == bigstp) {
					temp = xopt[i] - step * glag[i];
					if (temp <= sl[i]) {
						w[i] = sl[i] - xopt[i];
						wfixsq += w[i] * w[i];
					}
					else if (temp >= su[i]) {
						w[i] = su[i] - xopt[i];
						wfixsq += w[i] * w[i];
					}
					else {
						ggfree += glag[i] * glag[i];
					}
				}
			}
		} while (wfixsq > wsqsav && ggfree > zero);

		gw = zero;
		LOOP(i, n) {
			if (w[i] == bigstp) {
				w[i] = -step * glag[i];
				temp = xopt[i] + w[i];
				temp = MIN(temp, su[i]);
				xalt[i] = MAX(temp, sl[i]);
			}
			else if (w[i] == zero) {
				xalt[i] = xopt[i];
			}
			else if (glag[i] > zero) {
				xalt[i] = sl[i];
			}
			else {
				xalt[i] = su[i];
			}
			gw += glag[i] * w[i];
		}

		curv = zero;
		LOOP(k, npt) {
			temp = zero;
			LOOP(j, n) {
				temp += XPT(k, j) * w[j];
			}
			curv += hcol[k] * temp * temp;
		}
		if (iflag == 1) {
			curv = -curv;
		}
		if (curv > -gw && curv < -one_plus_sqrt2 * gw) {
			scale = -gw / curv;
			LOOP(i, n) {
				temp = xopt[i] + scale * w[i];
				temp = MIN(temp, su[i]);
				xalt[i] = MAX(temp, sl[i]);
			}
			temp = half * gw * scale;
			*cauchy = temp * temp;
		}
		else {
			temp = gw + half * curv;
			*cauchy = temp * temp;
		}

		if (iflag != 0) {
			break;
		}
		LOOP(i, n) {
			glag[i] = -glag[i];
			w[n + i] = xalt[i];
		}
		csave = *cauchy;
		iflag = 1;
	}
	if (csave > *cauchy) {
		LOOP(i, n) {
			xalt[i] = w[n + i];
		}
		*cauchy = csave;
	}
}

void trsbox(long n, long npt, double* xpt,
	double* xopt, double* gopt, double* hq, double* pq,
	double* sl, double* su, double delta, double* xnew,
	double* d, double* gnew, double* xbdi, double* s,
	double* hs, double* hred, double* dsq, double* crvmin)
{

	double half = 0.5;
	double one = 1.0;
	double onemin = -1.0;
	double zero = 0.0;
	double angbd, angt, beta, blen, cth, delsq, dhd, dhs, dredg, dredsq, ds,
		ggsav, gredsq, qred, rdnext, rdprev, redmax, rednew, redsav, resid,
		sdec, shs, sredg, ssq, stepsq, sth, stplen, temp, tempa, tempb, xsav, xsum;
	long i, iact, ih, isav, itcsav, iterc, itermax, iu, j, k, nact;

	xpt -= 1 + npt;
	xopt -= 1;
	gopt -= 1;
	hq -= 1;
	pq -= 1;
	sl -= 1;
	su -= 1;
	xnew -= 1;
	d -= 1;
	gnew -= 1;
	xbdi -= 1;
	s -= 1;
	hs -= 1;
	hred -= 1;

	angbd = zero;
	dredg = zero;
	dredsq = zero;
	ggsav = zero;
	gredsq = zero;
	rdnext = zero;
	sredg = zero;
	xsav = zero;
	iact = 0;
	itcsav = 0;
	itermax = 0;

	iterc = 0;
	nact = 0;
	LOOP(i, n) {
		xbdi[i] = zero;
		if (xopt[i] <= sl[i]) {
			if (gopt[i] >= zero) {
				xbdi[i] = onemin;
			}
		}
		else if (xopt[i] >= su[i]) {
			if (gopt[i] <= zero) {
				xbdi[i] = one;
			}
		}
		if (xbdi[i] != zero) {
			++nact;
		}
		d[i] = zero;
		gnew[i] = gopt[i];
	}
	delsq = delta * delta;
	qred = zero;
	*crvmin = onemin;

L20:
	beta = zero;
L30:
	stepsq = zero;
	LOOP(i, n) {
		if (xbdi[i] != zero) {
			s[i] = zero;
		}
		else if (beta == zero) {
			s[i] = -gnew[i];
		}
		else {
			s[i] = beta * s[i] - gnew[i];
		}
		stepsq += s[i] * s[i];
	}
	if (stepsq == zero) {
		goto L190;
	}
	if (beta == zero) {
		gredsq = stepsq;
		itermax = iterc + n - nact;
	}
	if (gredsq * delsq <= qred * 1e-4 * qred) {
		goto L190;
	}
	goto L210;
L50:
	resid = delsq;
	ds = zero;
	shs = zero;
	LOOP(i, n) {
		if (xbdi[i] == zero) {
			resid -= d[i] * d[i];
			ds += s[i] * d[i];
			shs += s[i] * hs[i];
		}
	}
	if (resid <= zero) {
		goto L90;
	}
	temp = sqrt(stepsq * resid + ds * ds);
	if (ds < zero) {
		blen = (temp - ds) / stepsq;
	}
	else {
		blen = resid / (temp + ds);
	}
	if (shs > zero) {
		stplen = gredsq / shs;
		stplen = MIN(blen, stplen);
	}
	else {
		stplen = blen;
	}
	iact = 0;
	LOOP(i, n) {
		if (s[i] != zero) {
			xsum = xopt[i] + d[i];
			if (s[i] > zero) {
				temp = (su[i] - xsum) / s[i];
			}
			else {
				temp = (sl[i] - xsum) / s[i];
			}
			if (temp < stplen) {
				stplen = temp;
				iact = i;
			}
		}
	}
	sdec = zero;
	if (stplen > zero) {
		++iterc;
		temp = shs / stepsq;
		if (iact == 0 && temp > zero) {
			*crvmin = MIN(*crvmin, temp);
			if (*crvmin == onemin) {
				*crvmin = temp;
			}
		}
		ggsav = gredsq;
		gredsq = zero;
		LOOP(i, n) {
			gnew[i] += stplen * hs[i];
			if (xbdi[i] == zero) {
				gredsq += gnew[i] * gnew[i];
			}
			d[i] += stplen * s[i];
		}
		sdec = stplen * (ggsav - half * stplen * shs);
		sdec = MAX(sdec, zero);
		qred += sdec;
	}
	if (iact > 0) {
		++nact;
		xbdi[iact] = one;
		if (s[iact] < zero) {
			xbdi[iact] = onemin;
		}
		delsq -= d[iact] * d[iact];
		if (delsq <= zero) {
			goto L90;
		}
		goto L20;
	}
	if (stplen < blen) {
		if (iterc == itermax) {
			goto L190;
		}
		if (sdec <= qred * 0.01) {
			goto L190;
		}
		beta = gredsq / ggsav;
		goto L30;
	}
L90:
	*crvmin = zero;
L100:
	if (nact >= n - 1) {
		goto L190;
	}
	dredsq = zero;
	dredg = zero;
	gredsq = zero;
	LOOP(i, n) {
		if (xbdi[i] == zero) {
			dredsq += d[i] * d[i];
			dredg += d[i] * gnew[i];
			gredsq += gnew[i] * gnew[i];
			s[i] = d[i];
		}
		else {
			s[i] = zero;
		}
	}
	itcsav = iterc;
	goto L210;
L120:
	++iterc;
	temp = gredsq * dredsq - dredg * dredg;
	if (temp <= qred * 1e-4 * qred) {
		goto L190;
	}
	temp = sqrt(temp);
	LOOP(i, n) {
		if (xbdi[i] == zero) {
			s[i] = (dredg * d[i] - dredsq * gnew[i]) / temp;
		}
		else {
			s[i] = zero;
		}
	}
	sredg = -temp;
	angbd = one;
	iact = 0;
	LOOP(i, n) {
		if (xbdi[i] == zero) {
			tempa = xopt[i] + d[i] - sl[i];
			tempb = su[i] - xopt[i] - d[i];
			if (tempa <= zero) {
				++nact;
				xbdi[i] = onemin;
				goto L100;
			}
			else if (tempb <= zero) {
				++nact;
				xbdi[i] = one;
				goto L100;
			}
			ssq = d[i] * d[i] + s[i] * s[i];
			temp = xopt[i] - sl[i];
			temp = ssq - temp * temp;
			if (temp > zero) {
				temp = sqrt(temp) - s[i];
				if (angbd * temp > tempa) {
					angbd = tempa / temp;
					iact = i;
					xsav = onemin;
				}
			}
			temp = su[i] - xopt[i];
			temp = ssq - temp * temp;
			if (temp > zero) {
				temp = sqrt(temp) + s[i];
				if (angbd * temp > tempb) {
					angbd = tempb / temp;
					iact = i;
					xsav = one;
				}
			}
		}
	}
	goto L210;
L150:
	shs = zero;
	dhs = zero;
	dhd = zero;
	LOOP(i, n) {
		if (xbdi[i] == zero) {
			shs += s[i] * hs[i];
			dhs += d[i] * hs[i];
			dhd += d[i] * hred[i];
		}
	}
	redmax = zero;
	isav = 0;
	redsav = zero;
	iu = (long)(angbd * 17.0 + 3.1);
	LOOP(i, iu) {
		angt = angbd * (double)i / (double)iu;
		sth = (angt + angt) / (one + angt * angt);
		temp = shs + angt * (angt * dhd - dhs - dhs);
		rednew = sth * (angt * dredg - sredg - half * sth * temp);
		if (rednew > redmax) {
			redmax = rednew;
			isav = i;
			rdprev = redsav;
		}
		else if (i == isav + 1) {
			rdnext = rednew;
		}
		redsav = rednew;
	}
	if (isav == 0) {
		goto L190;
	}
	if (isav < iu) {
		temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);
		angt = angbd * ((double)isav + half * temp) / (double)iu;
	}
	cth = (one - angt * angt) / (one + angt * angt);
	sth = (angt + angt) / (one + angt * angt);
	temp = shs + angt * (angt * dhd - dhs - dhs);
	sdec = sth * (angt * dredg - sredg - half * sth * temp);
	if (sdec <= zero) {
		goto L190;
	}
	dredg = zero;
	gredsq = zero;
	LOOP(i, n) {
		gnew[i] = gnew[i] + (cth - one) * hred[i] + sth * hs[i];
		if (xbdi[i] == zero) {
			d[i] = cth * d[i] + sth * s[i];
			dredg += d[i] * gnew[i];
			gredsq += gnew[i] * gnew[i];
		}
		hred[i] = cth * hred[i] + sth * hs[i];
	}
	qred += sdec;
	if (iact > 0 && isav == iu) {
		++nact;
		xbdi[iact] = xsav;
		goto L100;
	}
	if (sdec > qred * 0.01) {
		goto L120;
	}
L190:
	*dsq = zero;
	LOOP(i, n) {
		temp = xopt[i] + d[i];
		temp = MIN(temp, su[i]);
		xnew[i] = MAX(temp, sl[i]);
		if (xbdi[i] == onemin) {
			xnew[i] = sl[i];
		}
		if (xbdi[i] == one) {
			xnew[i] = su[i];
		}
		d[i] = xnew[i] - xopt[i];
		*dsq += d[i] * d[i];
	}
	return;
L210:
	ih = 0;
	LOOP(j, n) {
		hs[j] = zero;
		LOOP(i, j) {
			++ih;
			if (i < j) {
				hs[j] += hq[ih] * s[i];
			}
			hs[i] += hq[ih] * s[j];
		}
	}
	LOOP(k, npt) {
		if (pq[k] != zero) {
			temp = zero;
			LOOP(j, n) {
				temp += XPT(k, j) * s[j];
			}
			temp *= pq[k];
			LOOP(i, n) {
				hs[i] += temp * XPT(k, i);
			}
		}
	}
	if (*crvmin != zero) {
		goto L50;
	}
	if (iterc > itcsav) {
		goto L150;
	}
	LOOP(i, n) {
		hred[i] = hs[i];
	}
	goto L120;
}

void update(long n, long npt, double* bmat,
	double* zmat, long ndim, double* vlag, double beta,
	double denom, long knew, double* w)
{

	double one = 1.0;
	double zero = 0.0;
	double alpha, tau, temp, tempa, tempb, ztest;
	long i, j, jp, k, nptm;
	zmat -= 1 + npt;
	bmat -= 1 + ndim;
	vlag -= 1;
	w -= 1;
	nptm = npt - n - 1;
	ztest = zero;
	LOOP(k, npt) {
		LOOP(j, nptm) {
			temp = abs(ZMAT(k, j));
			ztest = MAX(ztest, temp);
		}
	}
	ztest *= 1e-20;
	for (j = 2; j <= nptm; ++j) {
		if (abs(ZMAT(knew, j)) > ztest) {
			tempa = ZMAT(knew, 1);
			tempb = ZMAT(knew, j);
			temp = sqrt(tempa * tempa + tempb * tempb);
			tempa /= temp;
			tempb /= temp;
			LOOP(i, npt) {
				temp = tempa * ZMAT(i, 1) + tempb * ZMAT(i, j);
				ZMAT(i, j) = tempa * ZMAT(i, j) - tempb * ZMAT(i, 1);
				ZMAT(i, 1) = temp;
			}
		}
		ZMAT(knew, j) = zero;
	}
	LOOP(i, npt) {
		w[i] = ZMAT(knew, 1) * ZMAT(i, 1);
	}
	alpha = w[knew];
	tau = vlag[knew];
	vlag[knew] -= one;
	temp = sqrt(denom);
	tempb = ZMAT(knew, 1) / temp;
	tempa = tau / temp;
	LOOP(i, npt) {
		ZMAT(i, 1) = tempa * ZMAT(i, 1) - tempb * vlag[i];
	}
	LOOP(j, n) {
		jp = npt + j;
		w[jp] = BMAT(knew, j);
		tempa = (alpha * vlag[jp] - tau * w[jp]) / denom;
		tempb = (-beta * w[jp] - tau * vlag[jp]) / denom;
		LOOP(i, jp) {
			BMAT(i, j) = BMAT(i, j) + tempa * vlag[i] + tempb * w[i];
			if (i > npt) {
				BMAT(jp, i - npt) = BMAT(i, j);
			}
		}
	}
}

void rescue(long n, long npt,
	double (*objfun)(double*, void*),
	double* xl, double* xu,
	double* xbase, double* xpt, double* fval, double* xopt,
	double* gopt, double* hq, double* pq, double* bmat, double* zmat,
	long ndim, double* sl, double* su, long* nf,
	double delta, long* kopt, double* vlag, double* ptsaux,
	double* ptsid, double* w, void* data)
{

	double half = 0.5;
	double one = 1.0;
	double zero = 0.0;
	double beta, bsum, den, denom, diff, distsq, dsqmin, f, fbase, hdiag,
		sfrac, sum, sumpq, temp, vlmxsq, vquad, winc, xp, xq;
	long i, ih, ihp, ihq, ip, iq, iw, j, jp, jpn, k, knew, kold, kpt,
		np, nptm, nrem;

	xp = 0;
	xq = 0;
	ihp = 0;
	ihq = 0;
	zmat -= 1 + npt;
	xpt -= 1 + npt;
	xl -= 1;
	xu -= 1;
	xbase -= 1;
	fval -= 1;
	xopt -= 1;
	gopt -= 1;
	hq -= 1;
	pq -= 1;
	bmat -= 1 + ndim;
	sl -= 1;
	su -= 1;
	vlag -= 1;
	ptsaux -= 3;
	ptsid -= 1;
	w -= 1;
	beta = zero;
	denom = zero;
	np = n + 1;
	sfrac = half / (double)np;
	nptm = npt - np;
	sumpq = zero;
	winc = zero;
	LOOP(k, npt) {
		distsq = zero;
		LOOP(j, n) {
			XPT(k, j) = XPT(k, j) - xopt[j];
			distsq += XPT(k, j) * XPT(k, j);
		}
		sumpq += pq[k];
		w[ndim + k] = distsq;
		winc = MAX(winc, distsq);
		LOOP(j, nptm) {
			ZMAT(k, j) = zero;
		}
	}
	ih = 0;
	LOOP(j, n) {
		w[j] = half * sumpq * xopt[j];
		LOOP(k, npt) {
			w[j] += pq[k] * XPT(k, j);
		}
		LOOP(i, j) {
			++ih;
			hq[ih] = hq[ih] + w[i] * xopt[j] + w[j] * xopt[i];
		}
	}
	LOOP(j, n) {
		xbase[j] += xopt[j];
		sl[j] -= xopt[j];
		su[j] -= xopt[j];
		xopt[j] = zero;
		PTSAUX(1, j) = MIN(delta, su[j]);
		PTSAUX(2, j) = MAX(-delta, sl[j]);
		if (PTSAUX(1, j) + PTSAUX(2, j) < zero) {
			temp = PTSAUX(1, j);
			PTSAUX(1, j) = PTSAUX(2, j);
			PTSAUX(2, j) = temp;
		}
		if (abs(PTSAUX(2, j)) < half * abs(PTSAUX(1, j))) {
			PTSAUX(2, j) = half * PTSAUX(1, j);
		}
		LOOP(i, ndim) {
			BMAT(i, j) = zero;
		}
	}
	fbase = fval[*kopt];
	ptsid[1] = sfrac;
	LOOP(j, n) {
		jp = j + 1;
		jpn = jp + n;
		ptsid[jp] = (double)j + sfrac;
		if (jpn <= npt) {
			ptsid[jpn] = (double)j / (double)np + sfrac;
			temp = one / (PTSAUX(1, j) - PTSAUX(2, j));
			BMAT(jp, j) = -temp + one / PTSAUX(1, j);
			BMAT(jpn, j) = temp + one / PTSAUX(2, j);
			BMAT(1, j) = -BMAT(jp, j) - BMAT(jpn, j);
			ZMAT(1, j) = sqrt(2.0) / abs(PTSAUX(1, j) * PTSAUX(2, j));
			ZMAT(jp, j) = ZMAT(1, j) * PTSAUX(2, j) * temp;
			ZMAT(jpn, j) = -ZMAT(1, j) * PTSAUX(1, j) * temp;
		}
		else {
			BMAT(1, j) = -one / PTSAUX(1, j);
			BMAT(jp, j) = one / PTSAUX(1, j);
			BMAT(j + npt, j) = -half * (PTSAUX(1, j) * PTSAUX(1, j));
		}
	}
	if (npt >= n + np) {
		for (k = 2 * np; k <= npt; ++k) {
			iw = (long)(((double)(k - np) - half) / (double)n);
			ip = k - np - iw * n;
			iq = ip + iw;
			if (iq > n) {
				iq -= n;
			}
			ptsid[k] = (double)ip + (double)iq / (double)np + sfrac;
			temp = one / (PTSAUX(1, ip) * PTSAUX(1, iq));
			ZMAT(1, k - np) = temp;
			ZMAT(ip + 1, k - np) = -temp;
			ZMAT(iq + 1, k - np) = -temp;
			ZMAT(k, k - np) = temp;
		}
	}
	nrem = npt;
	kold = 1;
	knew = *kopt;
L80:
	LOOP(j, n) {
		temp = BMAT(kold, j);
		BMAT(kold, j) = BMAT(knew, j);
		BMAT(knew, j) = temp;
	}
	LOOP(j, nptm) {
		temp = ZMAT(kold, j);
		ZMAT(kold, j) = ZMAT(knew, j);
		ZMAT(knew, j) = temp;
	}
	ptsid[kold] = ptsid[knew];
	ptsid[knew] = zero;
	w[ndim + knew] = zero;
	--nrem;
	if (knew != *kopt) {
		temp = vlag[kold];
		vlag[kold] = vlag[knew];
		vlag[knew] = temp;
		update(n, npt, &BMAT(1, 1), &ZMAT(1, 1), ndim, &vlag[1],
			beta, denom, knew, &w[1]);
		if (nrem == 0) {
			goto L350;
		}
		LOOP(k, npt) {
			w[ndim + k] = abs(w[ndim + k]);
		}
	}
L120:
	dsqmin = zero;
	LOOP(k, npt) {
		if (w[ndim + k] > zero) {
			if (dsqmin == zero || w[ndim + k] < dsqmin) {
				knew = k;
				dsqmin = w[ndim + k];
			}
		}
	}
	if (dsqmin == zero) {
		goto L260;
	}
	LOOP(j, n) {
		w[npt + j] = XPT(knew, j);
	}
	LOOP(k, npt) {
		sum = zero;
		if (k == *kopt) {
		}
		else if (ptsid[k] == zero) {
			LOOP(j, n) {
				sum += w[npt + j] * XPT(k, j);
			}
		}
		else {
			ip = (long)ptsid[k];
			if (ip > 0) {
				sum = w[npt + ip] * PTSAUX(1, ip);
			}
			iq = (long)((double)np * ptsid[k] - (double)(ip * np));
			if (iq > 0) {
				iw = 1;
				if (ip == 0) {
					iw = 2;
				}
				sum += w[npt + iq] * PTSAUX(iw, iq);
			}
		}
		w[k] = half * sum * sum;
	}
	LOOP(k, npt) {
		sum = zero;
		LOOP(j, n) {
			sum += BMAT(k, j) * w[npt + j];
		}
		vlag[k] = sum;
	}
	beta = zero;
	LOOP(j, nptm) {
		sum = zero;
		LOOP(k, npt) {
			sum += ZMAT(k, j) * w[k];
		}
		beta -= sum * sum;
		LOOP(k, npt) {
			vlag[k] += sum * ZMAT(k, j);
		}
	}
	bsum = zero;
	distsq = zero;
	LOOP(j, n) {
		sum = zero;
		LOOP(k, npt) {
			sum += BMAT(k, j) * w[k];
		}
		jp = j + npt;
		bsum += sum * w[jp];
		for (ip = npt + 1; ip <= ndim; ++ip) {
			sum += BMAT(ip, j) * w[ip];
		}
		bsum += sum * w[jp];
		vlag[jp] = sum;
		distsq += XPT(knew, j) * XPT(knew, j);
	}
	beta = half * distsq * distsq + beta - bsum;
	vlag[*kopt] += one;
	denom = zero;
	vlmxsq = zero;
	LOOP(k, npt) {
		if (ptsid[k] != zero) {
			hdiag = zero;
			LOOP(j, nptm) {
				hdiag += ZMAT(k, j) * ZMAT(k, j);
			}
			den = beta * hdiag + vlag[k] * vlag[k];
			if (den > denom) {
				kold = k;
				denom = den;
			}
		}
		temp = vlag[k] * vlag[k];
		vlmxsq = MAX(vlmxsq, temp);
	}
	if (denom <= vlmxsq * 0.01) {
		w[ndim + knew] = -w[ndim + knew] - winc;
		goto L120;
	}
	goto L80;
L260:
	LOOP(kpt, npt) {
		if (ptsid[kpt] == zero) {
			continue;
		}
		ih = 0;
		LOOP(j, n) {
			w[j] = XPT(kpt, j);
			XPT(kpt, j) = zero;
			temp = pq[kpt] * w[j];
			LOOP(i, j) {
				++ih;
				hq[ih] += temp * w[i];
			}
		}
		pq[kpt] = zero;
		ip = (long)ptsid[kpt];
		iq = (long)((double)np * ptsid[kpt] - (double)(ip * np))
			;
		if (ip > 0) {
			xp = PTSAUX(1, ip);
			XPT(kpt, ip) = xp;
		}
		if (iq > 0) {
			xq = PTSAUX(1, iq);
			if (ip == 0) {
				xq = PTSAUX(2, iq);
			}
			XPT(kpt, iq) = xq;
		}

		vquad = fbase;
		if (ip > 0) {
			ihp = (ip + ip * ip) / 2;
			vquad += xp * (gopt[ip] + half * xp * hq[ihp]);
		}
		if (iq > 0) {
			ihq = (iq + iq * iq) / 2;
			vquad += xq * (gopt[iq] + half * xq * hq[ihq]);
			if (ip > 0) {
				iw = MAX(ihp, ihq) - (ip >= iq ? ip - iq : iq - ip);
				vquad += xp * xq * hq[iw];
			}
		}
		LOOP(k, npt) {
			temp = zero;
			if (ip > 0) {
				temp += xp * XPT(k, ip);
			}
			if (iq > 0) {
				temp += xq * XPT(k, iq);
			}
			vquad += half * pq[k] * temp * temp;
		}

		LOOP(i, n) {
			temp = xbase[i] + XPT(kpt, i);
			temp = MAX(temp, xl[i]);
			w[i] = MIN(temp, xu[i]);
			if (XPT(kpt, i) == sl[i]) {
				w[i] = xl[i];
			}
			if (XPT(kpt, i) == su[i]) {
				w[i] = xu[i];
			}
		}
		++(*nf);
		f = objfun(w, data); // objfun(n, &w[1], data)
		fval[kpt] = f;
		if (f < fval[*kopt]) {
			*kopt = kpt;
		}
		diff = f - vquad;

		LOOP(i, n) {
			gopt[i] += diff * BMAT(kpt, i);
		}
		LOOP(k, npt) {
			sum = zero;
			LOOP(j, nptm) {
				sum += ZMAT(k, j) * ZMAT(kpt, j);
			}
			temp = diff * sum;
			if (ptsid[k] == zero) {
				pq[k] += temp;
			}
			else {
				ip = (long)ptsid[k];
				iq = (long)((double)np * ptsid[k] - (double)(ip * np));
				ihq = (iq * iq + iq) / 2;
				if (ip == 0) {
					hq[ihq] += temp * (PTSAUX(2, iq) * PTSAUX(2, iq));
				}
				else {
					ihp = (ip * ip + ip) / 2;
					hq[ihp] += temp * (PTSAUX(1, ip) * PTSAUX(1, ip));
					if (iq > 0) {
						hq[ihq] += temp * (PTSAUX(1, iq) * PTSAUX(1, iq));
						iw = MAX(ihp, ihq) - (ip >= iq ? ip - iq : iq - ip);
						hq[iw] += temp * PTSAUX(1, ip) * PTSAUX(1, iq);
					}
				}
			}
		}
		ptsid[kpt] = zero;
	}
L350:
	return;
}

int bobyqb(long n, long npt,
	double (*objfun)(double*, void*),
	double* x, double* xl, double* xu,
	double rhobeg, double rhoend,
	double* xbase, double* xpt, double* fval,
	double* xopt, double* gopt, double* hq,
	double* pq, double* bmat, double* zmat,
	long ndim, double* sl, double* su, double* xnew,
	double* xalt, double* d, double* vlag, double* w, void* data)
{
	double half = 0.5;
	double one = 1.0;
	double ten = 10.0;
	double tenth = 0.1;
	double two = 2.0;
	double zero = 0.0;
	double adelt, alpha, bdtest, bdtol, beta, biglsq, bsum, cauchy, crvmin,
		curv, delsq, delta, den, denom, densav, diff, diffa, diffb, diffc,
		dist, distsq, dnorm, dsq, dx, errbig, f, fopt, fracsq, frhosq, fsave,
		gisq, gqsq, hdiag, pqold, ratio, rho, scaden, sum, suma, sumb, sumpq,
		sumw, sumz, temp, tempa, tempb, vquad, xoptsq;
	long i, ih, ip, itest, j, jj, jp, k, kbase, knew, kopt, ksav, nf,
		nfsav, nh, np, nptm, nresc, ntrits;
	int status = BOBYQA_SUCCESS;
	const char* reason = NULL;
	int iter = 0;
	beta = 0;
	x -= 1;
	xl -= 1;
	xu -= 1;
	xbase -= 1;
	xpt -= 1 + npt;
	fval -= 1;
	xopt -= 1;
	gopt -= 1;
	hq -= 1;
	pq -= 1;
	bmat -= 1 + ndim;
	zmat -= 1 + npt;
	sl -= 1;
	su -= 1;
	xnew -= 1;
	xalt -= 1;
	d -= 1;
	vlag -= 1;
	w -= 1;
	adelt = zero;
	alpha = zero;
	cauchy = zero;
	denom = zero;
	diff = zero;
	diffc = zero;
	f = zero;
	knew = 0;
	np = n + 1;
	nptm = npt - np;
	nh = n * np / 2;

	prelim(n, npt, objfun, &x[1], &xl[1], &xu[1], rhobeg, &xbase[1],
		&XPT(1, 1), &fval[1], &gopt[1], &hq[1], &pq[1], &BMAT(1, 1),
		&ZMAT(1, 1), ndim, &sl[1], &su[1], &nf, &kopt, data);
	xoptsq = zero;
	LOOP(i, n) {
		xopt[i] = XPT(kopt, i);
		xoptsq += xopt[i] * xopt[i];
	}
	fsave = fval[1];
	kbase = 1;

	rho = rhobeg;
	delta = rho;
	nresc = nf;
	ntrits = 0;
	diffa = zero;
	diffb = zero;
	itest = 0;
	nfsav = nf;

L20:
	if (kopt != kbase) {
		ih = 0;
		LOOP(j, n) {
			LOOP(i, j) {
				++ih;
				if (i < j) {
					gopt[j] += hq[ih] * xopt[i];
				}
				gopt[i] += hq[ih] * xopt[j];
			}
		}
		if (nf > npt) {
			LOOP(k, npt) {
				temp = zero;
				LOOP(j, n) {
					temp += XPT(k, j) * xopt[j];
				}
				temp = pq[k] * temp;
				LOOP(i, n) {
					gopt[i] += temp * XPT(k, i);
				}
			}
		}
	}

L60:
	trsbox(n, npt, &XPT(1, 1), &xopt[1], &gopt[1], &hq[1], &pq[1],
		&sl[1], &su[1], delta, &xnew[1], &d[1], &w[1], &w[np],
		&w[np + n], &w[np + 2 * n], &w[np + n * 3], &dsq, &crvmin);
	iter++;
	dnorm = sqrt(dsq);
	dnorm = MIN(dnorm, delta);
	if (dnorm < half * rho) {
		ntrits = -1;
		tempa = ten * rho;
		distsq = tempa * tempa;
		if (nf <= nfsav + 2) {
			goto L650;
		}
		errbig = MAX(diffa, diffb);
		errbig = MAX(errbig, diffc);
		frhosq = rho * 0.125 * rho;
		if (crvmin > zero && errbig > frhosq * crvmin) {
			goto L650;
		}
		bdtol = errbig / rho;
		LOOP(j, n) {
			bdtest = bdtol;
			if (xnew[j] == sl[j]) {
				bdtest = w[j];
			}
			if (xnew[j] == su[j]) {
				bdtest = -w[j];
			}
			if (bdtest < bdtol) {
				curv = hq[(j + j * j) / 2];
				LOOP(k, npt) {
					curv += pq[k] * (XPT(k, j) * XPT(k, j));
				}
				bdtest += half * curv * rho;
				if (bdtest < bdtol) {
					goto L650;
				}
			}
		}
		goto L680;
	}
	++ntrits;
L90:
	if (dsq <= xoptsq * 0.001) {
		fracsq = xoptsq * 0.25;
		sumpq = zero;
		LOOP(k, npt) {
			sumpq += pq[k];
			sum = -half * xoptsq;
			LOOP(i, n) {
				sum += XPT(k, i) * xopt[i];
			}
			w[npt + k] = sum;
			temp = fracsq - half * sum;
			LOOP(i, n) {
				w[i] = BMAT(k, i);
				vlag[i] = sum * XPT(k, i) + temp * xopt[i];
				ip = npt + i;
				LOOP(j, i) {
					BMAT(ip, j) = BMAT(ip, j) + w[i] * vlag[j] + vlag[i] * w[j];
				}
			}
		}

		LOOP(jj, nptm) {
			sumz = zero;
			sumw = zero;
			LOOP(k, npt) {
				sumz += ZMAT(k, jj);
				vlag[k] = w[npt + k] * ZMAT(k, jj);
				sumw += vlag[k];
			}
			LOOP(j, n) {
				sum = (fracsq * sumz - half * sumw) * xopt[j];
				LOOP(k, npt) {
					sum += vlag[k] * XPT(k, j);
				}
				w[j] = sum;
				LOOP(k, npt) {
					BMAT(k, j) = BMAT(k, j) + sum * ZMAT(k, jj);
				}
			}
			LOOP(i, n) {
				ip = i + npt;
				temp = w[i];
				LOOP(j, i) {
					BMAT(ip, j) = BMAT(ip, j) + temp * w[j];
				}
			}
		}

		ih = 0;
		LOOP(j, n) {
			w[j] = -half * sumpq * xopt[j];
			LOOP(k, npt) {
				w[j] += pq[k] * XPT(k, j);
				XPT(k, j) = XPT(k, j) - xopt[j];
			}
			LOOP(i, j) {
				++ih;
				hq[ih] = hq[ih] + w[i] * xopt[j] + xopt[i] * w[j];
				BMAT(npt + i, j) = BMAT(npt + j, i);
			}
		}
		LOOP(i, n) {
			xbase[i] += xopt[i];
			xnew[i] -= xopt[i];
			sl[i] -= xopt[i];
			su[i] -= xopt[i];
			xopt[i] = zero;
		}
		xoptsq = zero;
	}
	if (ntrits == 0) {
		goto L210;
	}
	goto L230;

L190:
	nfsav = nf;
	kbase = kopt;
	rescue(n, npt, objfun, &xl[1], &xu[1], &xbase[1],
		&XPT(1, 1), &fval[1], &xopt[1], &gopt[1], &hq[1],
		&pq[1], &BMAT(1, 1), &ZMAT(1, 1), ndim, &sl[1], &su[1],
		&nf, delta, &kopt, &vlag[1], &w[1], &w[n + np], &w[ndim + np], data);

	xoptsq = zero;
	if (kopt != kbase) {
		LOOP(i, n) {
			xopt[i] = XPT(kopt, i);
			xoptsq += xopt[i] * xopt[i];
		}
	}
	nresc = nf;
	if (nfsav < nf) {
		nfsav = nf;
		goto L20;
	}
	if (ntrits > 0) {
		goto L60;
	}

L210:
	altmov(n, npt, &XPT(1, 1), &xopt[1], &BMAT(1, 1), &ZMAT(1, 1), ndim,
		&sl[1], &su[1], kopt, knew, adelt, &xnew[1], &xalt[1],
		&alpha, &cauchy, &w[1], &w[np], &w[ndim + 1]);
	LOOP(i, n) {
		d[i] = xnew[i] - xopt[i];
	}

L230:
	LOOP(k, npt) {
		suma = zero;
		sumb = zero;
		sum = zero;
		LOOP(j, n) {
			suma += XPT(k, j) * d[j];
			sumb += XPT(k, j) * xopt[j];
			sum += BMAT(k, j) * d[j];
		}
		w[k] = suma * (half * suma + sumb);
		vlag[k] = sum;
		w[npt + k] = suma;
	}
	beta = zero;
	LOOP(jj, nptm) {
		sum = zero;
		LOOP(k, npt) {
			sum += ZMAT(k, jj) * w[k];
		}
		beta -= sum * sum;
		LOOP(k, npt) {
			vlag[k] += sum * ZMAT(k, jj);
		}
	}
	dsq = zero;
	bsum = zero;
	dx = zero;
	LOOP(j, n) {
		dsq += d[j] * d[j];
		sum = zero;
		LOOP(k, npt) {
			sum += w[k] * BMAT(k, j);
		}
		bsum += sum * d[j];
		jp = npt + j;
		LOOP(i, n) {
			sum += BMAT(jp, i) * d[i];
		}
		vlag[jp] = sum;
		bsum += sum * d[j];
		dx += d[j] * xopt[j];
	}
	beta = dx * dx + dsq * (xoptsq + dx + dx + half * dsq) + beta - bsum;
	vlag[kopt] += one;
	if (ntrits == 0) {
		denom = vlag[knew] * vlag[knew] + alpha * beta;
		if (denom < cauchy && cauchy > zero) {
			LOOP(i, n) {
				xnew[i] = xalt[i];
				d[i] = xnew[i] - xopt[i];
			}
			cauchy = zero;
			goto L230;
		}
		if (denom <= half * (vlag[knew] * vlag[knew])) {
			if (nf > nresc) {
				goto L190;
			}
			goto cancellation_of_denominator;
		}

	}
	else {
		delsq = delta * delta;
		scaden = zero;
		biglsq = zero;
		knew = 0;
		LOOP(k, npt) {
			if (k == kopt) continue;
			hdiag = zero;
			LOOP(jj, nptm) {
				hdiag += ZMAT(k, jj) * ZMAT(k, jj);
			}
			den = beta * hdiag + vlag[k] * vlag[k];
			distsq = zero;
			LOOP(j, n) {
				tempa = XPT(k, j) - xopt[j];
				distsq += tempa * tempa;
			}
			temp = distsq / delsq;
			temp = temp * temp;
			temp = MAX(one, temp);
			if (temp * den > scaden) {
				scaden = temp * den;
				knew = k;
				denom = den;
			}
			temp *= vlag[k] * vlag[k];
			biglsq = MAX(biglsq, temp);
		}
		if (scaden <= half * biglsq) {
			if (nf > nresc) {
				goto L190;
			}
			goto cancellation_of_denominator;
		}
	}
L360:
	LOOP(i, n) {
		tempa = xbase[i] + xnew[i];
		tempa = MAX(tempa, xl[i]);
		x[i] = MIN(tempa, xu[i]);
		if (xnew[i] == sl[i]) {
			x[i] = xl[i];
		}
		if (xnew[i] == su[i]) {
			x[i] = xu[i];
		}
	}
	++nf;
	f = objfun(x, data); //objfun(n, &x[1], data);
	if (ntrits == -1) {
		fsave = f;
		goto done;
	}
	fopt = fval[kopt];
	vquad = zero;
	ih = 0;
	LOOP(j, n) {
		vquad += d[j] * gopt[j];
		LOOP(i, j) {
			++ih;
			temp = d[i] * d[j];
			if (i == j) {
				temp = half * temp;
			}
			vquad += hq[ih] * temp;
		}
	}
	LOOP(k, npt) {
		vquad += half * pq[k] * (w[npt + k] * w[npt + k]);
	}
	diff = f - fopt - vquad;
	diffc = diffb;
	diffb = diffa;
	diffa = abs(diff);
	if (dnorm > rho) {
		nfsav = nf;
	}
	if (ntrits > 0) {
		if (vquad >= zero) {
			goto step_failed;
		}
		ratio = (f - fopt) / vquad;
		if (ratio <= tenth) {
			delta *= half;
			delta = MIN(delta, dnorm);
		}
		else if (ratio <= 0.7) {
			delta *= half;
			delta = MAX(delta, dnorm);
		}
		else {
			tempa = dnorm + dnorm;
			delta *= half;
			delta = MAX(delta, tempa);
		}
		if (delta <= rho * 1.5) {
			delta = rho;
		}
		if (f < fopt) {
			ksav = knew;
			densav = denom;
			delsq = delta * delta;
			scaden = zero;
			biglsq = zero;
			knew = 0;
			LOOP(k, npt) {
				hdiag = zero;
				LOOP(jj, nptm) {
					hdiag += ZMAT(k, jj) * ZMAT(k, jj);
				}
				den = beta * hdiag + vlag[k] * vlag[k];
				distsq = zero;
				LOOP(j, n) {
					temp = XPT(k, j) - xnew[j];
					distsq += temp * temp;
				}
				temp = distsq / delsq;
				temp = temp * temp;
				temp = MAX(one, temp);
				if (temp * den > scaden) {
					scaden = temp * den;
					knew = k;
					denom = den;
				}
				temp *= (vlag[k] * vlag[k]);
				biglsq = MAX(biglsq, temp);
			}
			if (scaden <= half * biglsq) {
				knew = ksav;
				denom = densav;
			}
		}
	}
	update(n, npt, &BMAT(1, 1), &ZMAT(1, 1), ndim, &vlag[1],
		beta, denom, knew, &w[1]);
	ih = 0;
	pqold = pq[knew];
	pq[knew] = zero;
	LOOP(i, n) {
		temp = pqold * XPT(knew, i);
		LOOP(j, i) {
			++ih;
			hq[ih] += temp * XPT(knew, j);
		}
	}
	LOOP(jj, nptm) {
		temp = diff * ZMAT(knew, jj);
		LOOP(k, npt) {
			pq[k] += temp * ZMAT(k, jj);
		}
	}
	fval[knew] = f;
	LOOP(i, n) {
		XPT(knew, i) = xnew[i];
		w[i] = BMAT(knew, i);
	}
	LOOP(k, npt) {
		suma = zero;
		LOOP(jj, nptm) {
			suma += ZMAT(knew, jj) * ZMAT(k, jj);
		}
		sumb = zero;
		LOOP(j, n) {
			sumb += XPT(k, j) * xopt[j];
		}
		temp = suma * sumb;
		LOOP(i, n) {
			w[i] += temp * XPT(k, i);
		}
	}
	LOOP(i, n) {
		gopt[i] += diff * w[i];
	}
	if (f < fopt) {
		kopt = knew;
		xoptsq = zero;
		ih = 0;
		LOOP(j, n) {
			xopt[j] = xnew[j];
			xoptsq += xopt[j] * xopt[j];
			LOOP(i, j) {
				++ih;
				if (i < j) {
					gopt[j] += hq[ih] * d[i];
				}
				gopt[i] += hq[ih] * d[j];
			}
		}
		LOOP(k, npt) {
			temp = zero;
			LOOP(j, n) {
				temp += XPT(k, j) * d[j];
			}
			temp = pq[k] * temp;
			LOOP(i, n) {
				gopt[i] += temp * XPT(k, i);
			}
		}
	}
	if (ntrits > 0) {
		LOOP(k, npt) {
			vlag[k] = fval[k] - fval[kopt];
			w[k] = zero;
		}
		LOOP(j, nptm) {
			sum = zero;
			LOOP(k, npt) {
				sum += ZMAT(k, j) * vlag[k];
			}
			LOOP(k, npt) {
				w[k] += sum * ZMAT(k, j);
			}
		}
		LOOP(k, npt) {
			sum = zero;
			LOOP(j, n) {
				sum += XPT(k, j) * xopt[j];
			}
			w[k + npt] = w[k];
			w[k] = sum * w[k];
		}
		gqsq = zero;
		gisq = zero;
		LOOP(i, n) {
			sum = zero;
			LOOP(k, npt) {
				sum = sum + BMAT(k, i) * vlag[k] + XPT(k, i) * w[k];
			}
			if (xopt[i] == sl[i]) {
				tempa = MIN(zero, gopt[i]);
				gqsq += tempa * tempa;
				tempa = MIN(zero, sum);
				gisq += tempa * tempa;
			}
			else if (xopt[i] == su[i]) {
				tempa = MAX(zero, gopt[i]);
				gqsq += tempa * tempa;
				tempa = MAX(zero, sum);
				gisq += tempa * tempa;
			}
			else {
				gqsq += gopt[i] * gopt[i];
				gisq += sum * sum;
			}
			vlag[npt + i] = sum;
		}
		++itest;
		if (gqsq < ten * gisq) {
			itest = 0;
		}
		if (itest >= 3) {
			long i1 = MAX(npt, nh);
			LOOP(i, i1) {
				if (i <= n) {
					gopt[i] = vlag[npt + i];
				}
				if (i <= npt) {
					pq[i] = w[npt + i];
				}
				if (i <= nh) {
					hq[i] = zero;
				}
				itest = 0;
			}
		}
	}
	if (ntrits == 0) {
		goto L60;
	}
	if (f <= fopt + tenth * vquad) {
		goto L60;
	}
	tempa = two * delta;
	tempb = ten * rho;
	tempa = tempa * tempa;
	tempb = tempb * tempb;
	distsq = MAX(tempa, tempb);
L650:
	knew = 0;
	LOOP(k, npt) {
		sum = zero;
		LOOP(j, n) {
			tempa = XPT(k, j) - xopt[j];
			sum += tempa * tempa;
		}
		if (sum > distsq) {
			knew = k;
			distsq = sum;
		}
	}
	if (knew > 0) {
		dist = sqrt(distsq);
		if (ntrits == -1) {
			tempa = tenth * delta;
			tempb = half * dist;
			delta = MIN(tempa, tempb);
			if (delta <= rho * 1.5) {
				delta = rho;
			}
		}
		ntrits = 0;
		adelt = tenth * dist;
		adelt = MIN(adelt, delta);
		adelt = MAX(adelt, rho);
		dsq = adelt * adelt;
		goto L90;
	}
	if (ntrits == -1) {
		goto L680;
	}
	if (ratio > zero) {
		goto L60;
	}
	if (MAX(delta, dnorm) > rho) {
		goto L60;
	}
L680:
	if (rho > rhoend) {
		delta = half * rho;
		ratio = rho / rhoend;
		if (ratio <= 16.0) {
			rho = rhoend;
		}
		else if (ratio <= 250.0) {
			rho = sqrt(ratio) * rhoend;
		}
		else {
			rho = tenth * rho;
		}
		delta = MAX(delta, rho);

		//cout << "Iteration " << iter << "\tRHO " << setprecision(1)
		//	<< scientific << rho << setprecision(defaultprecision)
		//	<< "\t" << (double)fval[kopt] << endl;
		printf("Iteration %d\tRHO %.1e\t%e\n", iter, rho, fval[kopt]);
		fflush(stdout);

		ntrits = 0;
		nfsav = nf;
		goto L60;
	}
	if (ntrits == -1) {
		goto L360;
	}
done:
	if (fval[kopt] <= fsave) {
		LOOP(i, n) {
			tempa = xbase[i] + xopt[i];
			tempa = MAX(tempa, xl[i]);
			x[i] = MIN(tempa, xu[i]);
			if (xopt[i] == sl[i]) {
				x[i] = xl[i];
			}
			if (xopt[i] == su[i]) {
				x[i] = xu[i];
			}
		}
		f = fval[kopt];
	}

	//cout << "Iteration " << iter << "\tRHO " << setprecision(1)
	//	<< scientific << rho << setprecision(defaultprecision)
	//	<< "\t" << (double)fval[kopt] << endl;// defaultfloat << endl;
	//cout.unsetf(ios_base::floatfield);
	printf("Iteration %d\tRHO %.1e\t%e\n", iter, rho, fval[kopt]);
	fflush(stdout);

	if (status == BOBYQA_SUCCESS) {
		xbase[1] = f;
	}
	return status;

cancellation_of_denominator:
	reason = "of much cancellation in a denominator";
	status = BOBYQA_ROUNDING_ERRORS;
	goto error;

step_failed:
	reason = "a trust region step has failed to reduce Q";
	status = BOBYQA_STEP_FAILED;
	goto error;

error:
	//cout << "\n\tReturn from BOBYQA because " << reason << '.' << endl;
	goto done;

}

#undef ZMAT
#undef BMAT
#undef XPT
#undef PTSAUX

int bobyqa(long n, long npt,
	double (*objfun)(double*, void*), double* x,
	double* xl, double* xu,
	double rhobeg, double rhoend,
	double* w, void* data)
{

	double zero = 0.0;
	double temp, tempa, tempb;
	long ibmat, id, ifv, igo, ihq, ipq, isl, isu, ivl, iw, ixa, ixb, ixn,
		ixo, ixp, izmat, j, jsl, jsu, ndim, np;

	w -= 1;
	//xu -= 1;
	//xl -= 1;
	//x -= 1;
	np = n + 1;
	if (npt < n + 2 || npt >(n + 2) * np / 2) {
		//cout << "\n\tReturn from BOBYQA because NPT is not in the required interval." << endl;
		return BOBYQA_BAD_NPT;
	}

	ndim = npt + n;
	ixb = 1;
	ixp = ixb + n;
	ifv = ixp + n * npt;
	ixo = ifv + npt;
	igo = ixo + n;
	ihq = igo + n;
	ipq = ihq + n * np / 2;
	ibmat = ipq + npt;
	izmat = ibmat + ndim * n;
	isl = izmat + npt * (npt - np);
	isu = isl + n;
	ixn = isu + n;
	ixa = ixn + n;
	id = ixa + n;
	ivl = id + n;
	iw = ivl + ndim;

	LOOP(j, n) {
		temp = xu[j] - xl[j];
		if (temp < rhobeg + rhobeg) {
			//cout << "\n\tReturn from BOBYQA because one of the differences XU(I)-XL(I) is less than 2*RHOBEG." << endl;
			return BOBYQA_TOO_CLOSE;
		}
		jsl = isl + j - 1;
		jsu = jsl + n;
		w[jsl] = xl[j] - x[j];
		w[jsu] = xu[j] - x[j];
		if (w[jsl] >= -rhobeg) {
			if (w[jsl] >= zero) {
				x[j] = xl[j];
				w[jsl] = zero;
				w[jsu] = temp;
			}
			else {
				x[j] = xl[j] + rhobeg;
				w[jsl] = -rhobeg;
				temp = xu[j] - x[j];
				w[jsu] = MAX(temp, rhobeg);
			}
		}
		else if (w[jsu] <= rhobeg) {
			if (w[jsu] <= zero) {
				x[j] = xu[j];
				w[jsl] = -temp;
				w[jsu] = zero;
			}
			else {
				x[j] = xu[j] - rhobeg;
				tempa = xl[j] - x[j];
				tempb = -rhobeg;
				w[jsl] = MIN(tempa, tempb);
				w[jsu] = rhobeg;
			}
		}
	}

	return bobyqb(n, npt, objfun, &x[1], &xl[1], &xu[1],
		rhobeg, rhoend,
		&w[ixb], &w[ixp], &w[ifv], &w[ixo], &w[igo],
		&w[ihq], &w[ipq], &w[ibmat], &w[izmat],
		ndim, &w[isl], &w[isu], &w[ixn], &w[ixa],
		&w[id], &w[ivl], &w[iw], data);

}
